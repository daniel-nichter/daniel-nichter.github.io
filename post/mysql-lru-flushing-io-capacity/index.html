<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <title>MySQL LRU Flushing and I/O Capacity</title>
  <meta property="og:title" content="MySQL LRU Flushing and I/O Capacity" />
  <meta name="description" content="InnoDB background LRU list flushing is not limited by innodb_io_capcity or innodb_io_capacity_max.
I&rsquo;ll prove it in this blog post, but since MySQL experts disagree (or don&rsquo;t know for sure), I&rsquo;d like you to prove me wrong.
This is not an intro; you&rsquo;ll need to know all the InnoDB details wrt page flushing.">
  <meta property="og:description" content="InnoDB background LRU list flushing is not limited by innodb_io_capcity or innodb_io_capacity_max.
I&rsquo;ll prove it in this blog post, but since MySQL experts disagree (or don&rsquo;t know for sure), I&rsquo;d like you to prove me wrong.
This is not an intro; you&rsquo;ll need to know all the InnoDB details wrt page flushing.">
  <meta name="author" content="Daniel Nichter"/>
  <link rel="apple-touch-icon" sizes="180x180" href="img/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">
  <meta property="og:url" content="https://hackmysql.com/post/mysql-lru-flushing-io-capacity/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Hack MySQL" />
  <meta name="generator" content="Hugo 0.99.1" />
  <link rel="canonical" href="https://hackmysql.com/post/mysql-lru-flushing-io-capacity/" />
  <link rel="alternate" href="https://hackmysql.com/index.xml" type="application/rss+xml" title="Hack MySQL">
  <link rel="stylesheet" href="https://hackmysql.com/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://hackmysql.com/css/atom-one-dark.css" />
  <link rel="stylesheet" href="https://hackmysql.com/css/main.css" />
</head>

  <body>
    <nav class="navbar navbar-default navbar-static-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://hackmysql.com/">Hack MySQL</a>
    </div>
    <div class="collapse navbar-collapse" id="main-navbar">
<div id="Ukraine">
<a href="https://help.unicef.org/ukraine-emergency">UNICEF</a>&mdash;<a href="https://www.icrc.org/en/donate/ukraine">ICRC</a>&mdash;<a href="https://donate.wck.org/">WCK</a>&nbsp;
<img src="/img/Flag_of_Ukraine.svg" height="50px" style="display:inline" alt="Flag of Ukraine"></img>
</div>
      <ul class="nav navbar-nav navbar-left">


            <li>
              <a title="About" href="/about/">About</a>
            </li>



            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">Archive</a>
              <div class="navlinks-children">

                  <a href="/archive/mysqlreport/">mysqlreport</a>

                  <a href="/archive/mysqlsla/">mysqlsla</a>

                  <a href="/archive/mysqlsniffer/">mysqlsniffer</a>

              </div>
            </li>



            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">Engineer</a>
              <div class="navlinks-children">

                  <a href="/eng/career-advice/">Career Advice</a>

                  <a href="/eng/cli-antipatterns/">Command-line Interface Antipatterns</a>

                  <a href="/eng/database-operations-manual/">Database Operations Manual</a>

                  <a href="/eng/write/">How to Write Well</a>

                  <a href="/eng/percentiles/">Percentiles</a>

              </div>
            </li>



            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">go</a>
              <div class="navlinks-children">

                  <a href="/golang/go-antipatterns/">Go Antipatterns</a>

                  <a href="/golang/go-single-character-names/">Go Single-character Names</a>

                  <a href="/golang/idiomatic-go/">Idiomatic Go</a>

              </div>
            </li>



            <li>
              <a title="Help" href="/help/">Help</a>
            </li>



            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">MySQL</a>
              <div class="navlinks-children">

                  <a href="/mysql-password-rotation-lambda/">MySQL Password Rotation with AWS Secrets Manager and Lambda</a>

                  <a href="/mysql-select-and-sort/">MySQL Select and Sort Status Variables</a>

                  <a href="/mysql-terminology-updates/">MySQL Terminology Updates</a>

                  <a href="/mysql-transaction-reporting/">MySQL Transaction Reporting</a>

              </div>
            </li>




      </ul>
	</div>
  </div>
</nav>


<div class="container">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main">
        <h1 class="post-title">MySQL LRU Flushing and I/O Capacity</h1>

        <div class="post-meta">


  <div>Sep 2, 2021</div>
  <div class="blog-tags">


        <a href="/tags/mysql">#mysql</a>

        <a href="/tags/innodb">#innodb</a>

        <a href="/tags/lru-flushing">#lru-flushing</a>

        <a href="/tags/io-capacity">#io-capacity</a>


  </div>
</div>


        <p>InnoDB background LRU list flushing is <em>not</em> limited by <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_io_capacity"><code>innodb_io_capcity</code></a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_io_capacity_max"><code>innodb_io_capacity_max</code></a>.
I&rsquo;ll prove it in this blog post, but since MySQL experts disagree (or don&rsquo;t know for sure), I&rsquo;d like you to prove me wrong.
This is not an intro; you&rsquo;ll need to know all the InnoDB details wrt page flushing.</p>
<h3 id="setup">Setup</h3>
<p>Running <em>8.0.26-debug MySQL Community Server - GPL - Debug</em> on Ubuntu 21.04 (via Docker).</p>
<p>my.cnf:</p>
<pre><code class="language-ini">[mysqld]

#
# Super low IO caps
#
innodb-io-capacity=200
innodb-io-capacity-max=400

#
# One page cleaner and double than default LRU scan depth
# One &quot;pc&quot; ensures that all IO is due to the one pc
#
innodb_page_cleaners=1
innodb_lru_scan_depth=2048

#
# Big log so checkpoint age is not an issue
# Little to no adapative/flush list flushing
#
innodb_log_file_size=128M

#
# Disable stuff we don't need/avoid extra writes
#
innodb-flush-sync=0
innodb-doublewrite=0
skip-log-bin
skip-innodb-adaptive-hash-index

#
# I like metrics
#
innodb_monitor_enable=module_buffer,module_log,module_trx
</code></pre>
<p>InnoDB buffer pool size is default: 128M.</p>
<p>Use <a href="https://github.com/akopytov/sysbench">sysbench</a> to create a table with one million rows.</p>
<p>A silly little Go program to report IOPS and page flush rates:</p>
<pre><code class="language-go">package main

import (
    &quot;context&quot;
    &quot;database/sql&quot;
    &quot;log&quot;
    &quot;time&quot;

    _ &quot;github.com/go-sql-driver/mysql&quot;
)

func main() {
    db, err := sql.Open(&quot;mysql&quot;, &quot;root:test@tcp(127.0.0.1:3306)/&quot;)
    if err != nil {
        log.Fatal(err)
    }
    if err := db.Ping(); err != nil {
        log.Fatal(err)
    }

    q := &quot;SELECT name, count FROM information_schema.innodb_metrics WHERE name IN ('os_data_reads','os_data_writes','buffer_flush_adaptive_total_pages','buffer_LRU_batch_flush_total_pages','buffer_flush_background_total_pages')&quot;
    var pr, pw, pl, plru, pbg int

    t := time.NewTicker(1 * time.Second)
    for range t.C {
        var reads, writes, list, lru, bg int
        rows, err := db.QueryContext(context.Background(), q)
        if err != nil {
            log.Fatal(err)
        }
        for rows.Next() {
            var name string
            var val int
            if err := rows.Scan(&amp;name, &amp;val); err != nil {
                log.Fatal(err)
            }
            switch name {
            case &quot;os_data_reads&quot;:
                reads = val
            case &quot;os_data_writes&quot;:
                writes = val
            case &quot;buffer_flush_adaptive_total_pages&quot;:
                list = val
            case &quot;buffer_LRU_batch_flush_total_pages&quot;:
                lru = val
            case &quot;buffer_flush_background_total_pages&quot;:
                bg = val
            default:
                log.Fatalf(&quot;unknown var %s&quot;, name)
            }
        }
        rows.Close()

        log.Printf(&quot;read = %4d  write = %4d | list = %4d  LRU = %4d  bg = %4d&quot;,
            reads-pr, writes-pw, list-pl, lru-plru, bg-pbg)

        pr = reads
        pw = writes
        pl = list
        plru = lru
        pbg = bg
    }
}
</code></pre>
<h3 id="few-free-pages-but-many-dirty-pages">Few Free Pages but Many Dirty Pages</h3>
<p>Since the page cleaners are <em>background</em> threads, you normally can&rsquo;t disable them.
But with a debug build of MySQL, you can:</p>
<pre><code class="language-sql">SET GLOBAL innodb_page_cleaner_disabled_debug=1;
</code></pre>
<p>This proof would be nearly impossible without that switch because, normally, the page cleaners will keep free pages at or near <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_lru_scan_depth"><code>innodb_lru_scan_depth</code></a>, which means you can&rsquo;t cause big LRU flushes.</p>
<p>But with the page cleaner disabled (normally, there are 4 page cleaners by default, by see my.cnf above: I configured only 1 page cleaner for this proof), you can nearly fill the buffer pool with unflushed dirty pages:</p>
<pre><code>mysql&gt; UPDATE sbtest2 SET c='a' WHERE id &lt; 500000;
Query OK, 400000 rows affected (36.11 sec)
Rows matched: 499999  Changed: 400000  Warnings: 0
</code></pre>
<p>The query doesn&rsquo;t matter.
What matters is that it creates many dirty pages:</p>
<pre><code>mysql&gt; SELECT name, count FROM innodb_metrics WHERE name LIKE 'buffer_pool_pages_%';
+-------------------------+-------+
| name                    | count |
+-------------------------+-------+
| buffer_pool_pages_total |  8192 |
| buffer_pool_pages_misc  |     0 |
| buffer_pool_pages_data  |  8128 |
| buffer_pool_pages_dirty |  5685 |
| buffer_pool_pages_free  |    64 |
+-------------------------+-------+
</code></pre>
<p>This is the weird situation needed to prove that LRU flushing does not use I/O capacities: significantly more dirty pages and LRU scan depth than max I/O, but almost no free pages to make LRU flushing kick in and work at peak rate.
And that&rsquo;s the crux of the test: is the peak rate of LRU flushing <code>innodb_io_capacity_max</code> or <code>innodb_lru_scan_depth</code>?
If it&rsquo;s the former (<code>innodb_io_capacity_max</code>), then LRU flushing will proceed in batches of (roughly) that many pages, especially since <code>innodb_flush_sync = 0</code>.
But if it&rsquo;s the latter (<code>innodb_lru_scan_depth</code>), then LRU flushing will proceed in a batch of (roughly) that many pages, which is greater than max I/O capacity.</p>
<h3 id="lru-flush-greater-than-max-io-capacity">LRU Flush Greater Than Max I/O Capacity</h3>
<p>Run the Go program (above), enable MySQL debugging/tracking, then enable the page cleaner:</p>
<pre><code>mysql&gt; SET GLOBAL DEBUG='d:t:i:o,/tmp/mysqld.trace:F:L';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SET GLOBAL innodb_page_cleaner_disabled_debug=0;
Query OK, 0 rows affected (0.06 sec)
</code></pre>
<p>The trace file confirms:</p>
<pre><code># grep 'flush 0' mysqld.trace
 ?file:  1986: ib_buf: flush 0 completed, 1178 pages
 ?file:  1986: ib_buf: flush 0 completed, 0 pages
</code></pre>
<p>&ldquo;flush 0&rdquo; is LRU flushing. (&ldquo;flush 1&rdquo;, not shown, is adaptive/LSN/flush list flushing.)</p>
<p>Also in the trace file:</p>
<pre><code> ?file:  1998: ib_buf: flush completed, from flush_list 122 pages, from LRU_list 1178 pages
</code></pre>
<p>The rates from the Go program match perfectly, affirming the trace data through other metrics:</p>
<pre><code class="language-none">2021/09/02 14:09:49 read =    0  write =    0 | list =    0  LRU =    0  bg =    0
2021/09/02 14:09:50 read =    0  write =    0 | list =    0  LRU =    0  bg =    0
2021/09/02 14:09:51 read =    0  write =    0 | list =    0  LRU =    0  bg =    0
2021/09/02 14:09:52 read =    0  write = 1300 | list =  122  LRU = 1178  bg =    0
2021/09/02 14:09:53 read =    0  write =    1 | list =    0  LRU =    0  bg =    0
2021/09/02 14:09:54 read =    0  write =  200 | list =    0  LRU =    0  bg =  200
2021/09/02 14:09:55 read =    0  write =  201 | list =    0  LRU =    0  bg =  200
2021/09/02 14:09:56 read =    0  write =  201 | list =    0  LRU =    0  bg =  200
</code></pre>
<p>First 3 lines were before the page cleaner was re-enabled: zero activity.</p>
<p>Fourth line is the proof: 1,178 pages flushed at 1,3000 write IOPS.</p>
<p>In the latter lines, the configured background flush rate is observed: 200.</p>
<h3 id="quick-source-code-analysis">Quick Source Code Analysis</h3>
<p>Background page flushing happens in <code>storage/innobase/buf/buf0flu.cc</code>.</p>
<p>Flushing (both list and LRU) starts in function <code>pc_flush_slot()</code>:</p>
<pre><code class="language-cpp">2979     /* Flush pages from end of LRU if required */
2980     slot-&gt;n_flushed_lru = buf_flush_LRU_list(buf_pool);
2981
2982     lru_tm = ut_time_monotonic_ms() - lru_tm;
2983     lru_pass++;
2984
2985     if (!page_cleaner-&gt;is_running) {
2986       slot-&gt;n_flushed_list = 0;
2987       goto finish;
2988     }
2989
2990     /* Flush pages from flush_list if required */
2991     if (page_cleaner-&gt;requested) {
2992       list_tm = ut_time_monotonic_ms();
2993
2994       slot-&gt;succeeded_list =
2995           buf_flush_do_batch(buf_pool, BUF_FLUSH_LIST, slot-&gt;n_pages_requested,
2996                              page_cleaner-&gt;lsn_limit, &amp;slot-&gt;n_flushed_list);
2997
2998       list_tm = ut_time_monotonic_ms() - list_tm;
2999       list_pass++;
3000     } else {
3001       slot-&gt;n_flushed_list = 0;
3002       slot-&gt;succeeded_list = true;
3003     }
</code></pre>
<p>(Line numbers added.)</p>
<p>In function <code>buf_flush_LRU_list()</code>:</p>
<pre><code class="language-cpp">2267   /* Currently one of page_cleaners is the only thread
       that can trigger an LRU flush at the same time.
       So, it is not possible that a batch triggered during
       last iteration is still running, */
2271   buf_flush_do_batch(buf_pool, BUF_FLUSH_LRU, scan_depth, 0, &amp;n_flushed);
</code></pre>
<p>And there it is: <code>scan_depth</code>.
If you continue following the code, you&rsquo;ll see that nothing attenuates <code>scan_depth</code> (the argument changes changes; ironically, in some functions the argument is <code>min</code> and in others it&rsquo;s <code>max</code>—MySQL source code is veritable jungle).</p>
<h3 id="io-capacity-max">I/O Capacity Max</h3>
<p>As expected and understood by everyone in the rarefied world of InnoDB internals, the adaptive flushing algorithm uses and limits flush list flushing to <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_io_capacity"><code>innodb_io_capcity</code></a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_io_capacity_max"><code>innodb_io_capacity_max</code></a>.</p>
<p>Back in <code>pc_flush_slot()</code>:</p>
<pre><code class="language-cpp">2994       slot-&gt;succeeded_list =
2995           buf_flush_do_batch(buf_pool, BUF_FLUSH_LIST, slot-&gt;n_pages_requested,
2996                              page_cleaner-&gt;lsn_limit, &amp;slot-&gt;n_flushed_list);
</code></pre>
<p>Argument <code>slot-&gt;n_pages_requested</code> is set by the adaptive flushing algorithm.
And you&rsquo;ll notice it&rsquo;s the same lower-level function call that LRU flushing uses: <code>buf_flush_do_batch()</code>.</p>
<h3 id="quick-historical-analysis">Quick Historical Analysis</h3>
<p>Is LRU flushing supposed to be limited by configured I/O capacity?
Was it ever?
If yes, when did it stop?
Down the rabbit hole of history!</p>
<p>In function <code>buf_flush_LRU_list_batch()</code>:</p>
<pre><code class="language-cpp">1832   /* We keep track of all flushes happening as part of LRU
       flush. When estimating the desired rate at which flush_list
       should be flushed, we factor in this value. */
1835   buf_lru_flush_page_count += count;
</code></pre>
<p>That code comment is very old and it&rsquo;s wrong: we do <em>not</em> keep track of this any longer—we haven&rsquo;t for a very long time.
<code>buf_lru_flush_page_count</code> is not used anywhere: it&rsquo;s incremented here, but never used.</p>
<p>This variable was last used in 5.5.
As of 5.6, it stopped being used (aside from being incremented).
A single page cleaner thread was introduced in 5.6 (and expanded to multiple page cleaner threads in 5.7), so this makes some sense: if LRU flush was ever supposed to be limited or capped by I/O capacity, this functionality was lost in the big page cleaner implementation from 5.5 to 5.6.</p>
<p>The related MySQL worklogs are:</p>
<ul>
<li><a href="https://dev.mysql.com/worklog/task/?id=5579">WL#5579: Add &lsquo;page_cleaner&rsquo; a separate thread to flush dirty pages</a></li>
<li><a href="https://dev.mysql.com/worklog/task/?id=5580">WL#5580: changes to LRU flushing</a></li>
<li><a href="https://dev.mysql.com/worklog/task/?id=6642">WL#6642: InnoDB: multiple page_cleaner threads</a></li>
</ul>
<h3 id="why-nobody-notices-or-cares">Why Nobody Notices or Cares</h3>
<p>Default LRU scan depth is 1024 which is less than the default I/O max capacity 2000.
With 4 page cleaners by default, that&rsquo;s 4 * 1024 = 4,096 LRU page flushes max.
But this is <em>very unlikely</em>, perhaps impossible because the buffer pool starts with free pages and the page cleaners maintain free pages.
As shown in section <a href="#few-free-pages-but-many-dirty-pages">Few Free Pages but Many Dirty Pages</a>, it&rsquo;s quite difficult to get MySQL/InnoDB into a state where there are very few free pages but a significant number of dirty pages.
The whole point of page flushing is to avoid this.
(That&rsquo;s not the <em>whole</em> point, but you know what I mean.)</p>
<p>Moreover, the general best practice is to reduce <code>innodb_lru_scan_depth</code>, especially when there are many buffer pool instances.
Let&rsquo;s say we reduce it to 512, then 512 * 4 = 2,048 LRU page flushes max, which is essentially the default max I/O capacity.
Moreover again, the max I/O capacity is likely to be higher on mid- to high-end hardware.</p>
<p>It&rsquo;s difficult to imagine a real application workload that would cause the LRU flushing rate to be noticed, let alone a problem in terms of exceeding the configured max I/O rate.
Nevertheless, this blog post proves that LRU flushing does not use and is not limited by <code>innodb_io_capcity</code> or <code>innodb_io_capacity_max</code>; instead, it flushes up to <code>innodb_lru_scan_depth</code> pages per page cleaner thread, but it is very unlikely—almost impossible—that this would cause any noticeable or problematic background I/O usage.</p>
      </article>
      <hr>
      <ul class="pager blog-pager">

          <li class="previous">
            <a href="https://hackmysql.com/post/mysql-data-locks-mapping-80-to-57/" data-toggle="tooltip" data-placement="top" title="MySQL Data Locks: Mapping 8.0 to 5.7">&larr; </a>
          </li>


          <li class="next">
            <a href="https://hackmysql.com/post/book-0/" data-toggle="tooltip" data-placement="top" title="Efficient MySQL Performance"> &rarr;</a>
          </li>

      </ul>



          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {



    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hackmongo" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>


    </div>
  </div>
</div>

    <footer>
  <p class="copyright text-muted">
    Copyright 2022 Daniel Nichter
  </p>
  <p><a href="https://github.com/daniel-nichter" alt="GitHub"><img src="https://hackmysql.com/img/mark-github.svg"></a></p>
</footer>
<script src="https://hackmysql.com/js/compressed.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="https://cdn.usefathom.com/script.js" data-site="WJIYGVMB" data-canonical="false" defer></script>


  </body>
</html>
