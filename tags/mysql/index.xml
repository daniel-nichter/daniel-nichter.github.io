<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mysql on Hack MySQL</title>
    <link>https://hackmysql.com/tags/mysql/</link>
    <description>Recent content in mysql on Hack MySQL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2020 Daniel Nichter</copyright>
    <lastBuildDate>Sun, 31 May 2020 00:00:00 +0000</lastBuildDate>

	<atom:link href="https://hackmysql.com/tags/mysql/index.xml" rel="self" type="application/rss+xml" />


    <item>
      <title>Gone GTID</title>
      <link>https://hackmysql.com/post/gone-gtid/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>

      <guid>https://hackmysql.com/post/gone-gtid/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/replication-gtids.html&#34;&gt;GTID-based replication&lt;/a&gt; makes managing replication topology easy: just &lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html&#34;&gt;CHANGE MASTER&lt;/a&gt; to any node and voilà. It &lt;a href=&#34;https://hackmysql.com/post/fixing-ghosted-gtids/&#34;&gt;doesn&amp;rsquo;t always work&lt;/a&gt;, but for the most part it does. That&amp;rsquo;s great, but it can hide a serious problem: missing writes. Even when MySQL GTID-based replication says, &amp;ldquo;OK, sure!&amp;quot;, which is most of the time, you should double check it.&lt;/p&gt;</description>
    </item>

    <item>
      <title>MySQL Threads Running</title>
      <link>https://hackmysql.com/post/mysql-threads-running-how-hard-is-mysql-working/</link>
      <pubDate>Sat, 25 Apr 2020 16:18:00 -0300</pubDate>

      <guid>https://hackmysql.com/post/mysql-threads-running-how-hard-is-mysql-working/</guid>
      <description>&lt;p&gt;Queries per second (QPS) measures database throughput, but it does not reflect how hard MySQL is working. The latter is measured by &lt;em&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html#statvar_Threads_running&#34;&gt;Threads_running&lt;/a&gt;&lt;/em&gt;, expressed as a gauge (whereas QPS is a rate). Before discussing &lt;em&gt;Threads_running&lt;/em&gt;, let&amp;rsquo;s consider an analogy:&lt;/p&gt;</description>
    </item>

    <item>
      <title>Queries Effect Performance</title>
      <link>https://hackmysql.com/post/queries-effect-performance/</link>
      <pubDate>Sun, 12 Jan 2020 00:00:00 +0000</pubDate>

      <guid>https://hackmysql.com/post/queries-effect-performance/</guid>
      <description>Queries effect database performance. That&amp;rsquo;s not a typo: &amp;ldquo;effect&amp;rdquo; not &amp;ldquo;affect&amp;rdquo;. The difference is not a word game but an important way to think about database performance.
Many things can affect performance. For example, if the system runs out of memory then starts swapping which causes high disk IO latency, that will negatively affect performance. But external factors like that notwithstanding (i.e. when hardware and MySQL are normal and stable), it&amp;rsquo;s important to understand that queries effect performance.</description>
    </item>

    <item>
      <title>Fixing Ghosted GTIDs</title>
      <link>https://hackmysql.com/post/fixing-ghosted-gtids/</link>
      <pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate>

      <guid>https://hackmysql.com/post/fixing-ghosted-gtids/</guid>
      <description>MySQL auto-positioning is an integral part of replication with GTID, but it&amp;rsquo;s neither required nor guaranteed to work. It&amp;rsquo;s possible to enable GTIDs but disable auto-positioning, and it&amp;rsquo;s possible that one MySQL instance cannot auto-position on another even when GTIDs are used. The former (GTID on but auto-pos off) is an issue for another time. The latter is the topic of this post: when MySQL GTID auto-positioning fails—and how to fix it.</description>
    </item>

    <item>
      <title>When MySQL Goes Away</title>
      <link>https://hackmysql.com/post/when-mysql-goes-away/</link>
      <pubDate>Sun, 22 Jul 2018 18:00:00 -0300</pubDate>

      <guid>https://hackmysql.com/post/when-mysql-goes-away/</guid>
      <description>Handling MySQL errors in Go is not easy. There are a lot of MySQL server error codes, and the Go MySQL driver as its own errors, and Go database/sql has its own errors, and errors can bubble up from other packages, like net.OpError. Consequently, Go programs tend not to handle errors. Instead, they simply report errors:
err := db.Query(...).Scan(&amp;amp;v) if err != nil { return err } And then the error is logged or reported somewhere.</description>
    </item>

    <item>
      <title>Crash-safe MySQL Replication</title>
      <link>https://hackmysql.com/post/crash-safe-mysql-replication-a-visual-guide/</link>
      <pubDate>Tue, 23 Jan 2018 18:40:00 -0700</pubDate>

      <guid>https://hackmysql.com/post/crash-safe-mysql-replication-a-visual-guide/</guid>
      <description>MySQL crash-safe replication is an old feature (~4 years as of MySQL 5.6), but it&amp;rsquo;s not consistently understood or applied. The MySQL manual on the topic, 16.3.2 Handling an Unexpected Halt of a Replication Slave, is correct and authoritative, but unless you grok MySQL replication that page doesn&amp;rsquo;t make it obvious why crash-safe replication works. Other blog posts explain why, but sometimes add other considerations, making it unclear which settings are necessary and sufficient.</description>
    </item>

  </channel>
</rss>
