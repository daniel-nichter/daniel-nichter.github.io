<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MySQL Select and Sort Status Variables</title>
  <meta property="og:title" content="MySQL Select and Sort Status Variables" />
  <meta name="description" content="A deep dive into the MySQL select and sort status variables">
  <meta property="og:description" content="A deep dive into the MySQL select and sort status variables">

  <meta name="author" content="Daniel Nichter"/>
  <link rel="apple-touch-icon" sizes="180x180" href="img/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">
  <meta property="og:url" content="https://hackmysql.com/mysql-select-and-sort/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Hack MySQL" />
  <meta name="generator" content="Hugo 0.109.0">
  <link rel="canonical" href="https://hackmysql.com/mysql-select-and-sort/" />
  <link rel="alternate" href="https://hackmysql.com/index.xml" type="application/rss+xml" title="Hack MySQL">
  <link rel="stylesheet" href="https://hackmysql.com/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://hackmysql.com/css/atom-one-dark.css" />
  <link rel="stylesheet" href="https://hackmysql.com/css/main.css" />
</head>

  <body>
    <nav class="navbar navbar-default navbar-static-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://hackmysql.com/">Hack MySQL</a>
    </div>
    <div class="collapse navbar-collapse" id="main-navbar">
<div id="Ukraine">
<a href="https://help.unicef.org/ukraine-emergency">UNICEF</a>&mdash;<a href="https://www.icrc.org/en/donate/ukraine">ICRC</a>&mdash;<a href="https://donate.wck.org/">WCK</a>&nbsp;
<img src="/img/Flag_of_Ukraine.svg" height="50px" style="display:inline" alt="Flag of Ukraine"></img>
</div>
      <ul class="nav navbar-nav navbar-left">


            <li>
              <a title="About" href="/about/">About</a>
            </li>



            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">Archive</a>
              <div class="navlinks-children">

                  <a href="/archive/mysqlreport/">mysqlreport</a>

                  <a href="/archive/mysqlsla/">mysqlsla</a>

                  <a href="/archive/mysqlsniffer/">mysqlsniffer</a>

              </div>
            </li>



            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">Engineer</a>
              <div class="navlinks-children">

                  <a href="/eng/career-advice/">Career Advice</a>

                  <a href="/eng/database-operations-manual/">Database Operations Manual</a>

                  <a href="/eng/write/">How to Write Well</a>

                  <a href="/eng/level-up/">Level Up</a>

                  <a href="/eng/percentiles/">Percentiles</a>

              </div>
            </li>



            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">go</a>
              <div class="navlinks-children">

                  <a href="/golang/go-antipatterns/">Go Antipatterns</a>

                  <a href="/golang/go-single-character-names/">Go Single-character Names</a>

                  <a href="/golang/idiomatic-go/">Idiomatic Go</a>

              </div>
            </li>



            <li>
              <a title="Help" href="/help/">Help</a>
            </li>



            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">MySQL</a>
              <div class="navlinks-children">

                  <a href="/mysql-password-rotation-lambda/">MySQL Password Rotation with AWS Secrets Manager and Lambda</a>

                  <a href="/mysql-select-and-sort/">MySQL Select and Sort Status Variables</a>

                  <a href="/mysql-transaction-reporting/">MySQL Transaction Reporting</a>

              </div>
            </li>




      </ul>
	</div>
  </div>
</nav>


<main class="page">
	<div id="art">
		<article role="main" class="blog-post"><h1 id="mysql-select-and-sort-status-variables">MySQL Select and Sort Status Variables</h1>
<p>This page is a reboot of the original written 15 years ago in 2005.
Back then, I must have been using MySQL 4.1 or 5.0.
Today, I am using MySQL 8.0.22.
A lot changed in MySQL from 4.1 to 8.0, but it still has the same <code>Select_%</code> and <code>Sort_%</code> status variables which are equally important today in 2021.
Let&rsquo;s examine them in greater detail and with better examples.</p>
<p class="note">
Check out my book to learn a lot more about MySQL performance:<br><br>
<a href="https://oreil.ly/efficient-mysql-performance"><img id="book-cover" src="/img/book/efficient-mysql-performance-cover.png" alt="Efficient MySQL Performance book cover" style="width:25%"></a>
</p>
<p>The MySQL <code>Select_%</code> and <code>Sort_%</code> status variables (metrics) are:</p>
<ul>
<li><code>Select_scan</code></li>
<li><code>Select_range</code></li>
<li><code>Select_full_join</code></li>
<li><code>Select_full_range_join</code></li>
<li><code>Select_range_check</code></li>
<li><code>Sort_scan</code></li>
<li><code>Sort_range</code></li>
<li><code>Sort_merge_passes</code></li>
<li><code>Sort_rows</code></li>
</ul>
<p>Using MySQL 8.0.22 Community, the test tables are:</p>
<pre tabindex="0"><code>CREATE TABLE `t1` (
  `id` int NOT NULL AUTO_INCREMENT,
  `c1` int NOT NULL,
  `c2` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `c1` (`c1`)
) ENGINE=InnoDB

CREATE TABLE `t2` (
  `id` int NOT NULL AUTO_INCREMENT,
  `c1` int NOT NULL,
  `c2` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `c1` (`c1`)
) ENGINE=InnoDB
</code></pre><p>Each table has about 30 rows.</p>
<h2 id="select">Select</h2>
<table>
<thead>
<tr>
<th>Metric</th>
<th>First Table</th>
<th>Join Table</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Select_scan</code></td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td><code>Select_range</code></td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td><code>Select_full_join</code></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>Select_full_range_join</code></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>Select_range_check</code></td>
<td></td>
<td>✓</td>
</tr>
</tbody>
</table>
<p><code>Select_scan</code> and <code>Select_range</code> apply to the first (or only) table. <code>Select_full_join</code>, <code>Select_full_range_join</code>, and <code>Select_range_check</code> apply to the second and subsequent tables.</p>
<p>MySQL table join order is determined by the query planner (to create the best execution plan) not the <a href="https://dev.mysql.com/doc/refman/8.0/en/join.html">JOIN clause</a> clause (unless STRAIGHT_JOIN is used).</p>
<pre tabindex="0"><code>mysql&gt; EXPLAIN SELECT * FROM t1, t2 WHERE t1.c1 = t2.c2 ORDER BY t1.c2;
+-------------+-------+------+---------------+------+---------+------------+------+----------+---------------------------------+
| select_type | table | type | possible_keys | key  | key_len | ref        | rows | filtered | Extra                           |
+-------------+-------+------+---------------+------+---------+------------+------+----------+---------------------------------+
| SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL       |   26 |   100.00 | Using temporary; Using filesort |
| SIMPLE      | t1    | ref  | c1            | c1   | 4       | test.t2.c2 |    1 |   100.00 | NULL                            |
+-------------+-------+------+---------------+------+---------+------------+------+----------+---------------------------------+

mysql&gt; EXPLAIN FORMAT=TREE SELECT * FROM t1, t2 WHERE t1.c1 = t2.c2 ORDER BY t1.c2;
+-------------------------------------------------------------------------+
| EXPLAIN                                                                 |
+-------------------------------------------------------------------------+
| -&gt; Sort: t1.c2
    -&gt; Stream results  (cost=11.95 rows=26)
        -&gt; Nested loop inner join  (cost=11.95 rows=26)
            -&gt; Table scan on t2  (cost=2.85 rows=26)
            -&gt; Index lookup on t1 using c1 (c1=t2.c2)  (cost=0.25 rows=1) |
+-------------------------------------------------------------------------+
</code></pre><p>Top output is a standard EXPLAIN plan with the first table on top, so <code>t2</code> is the first table and <code>t1</code> is the second table. Note that the tables are listed differently in the FROM clause. MySQL is accessing table <code>t2</code> first because it produces a better execution plan which you can see in detail by <a href="https://dev.mysql.com/doc/internals/en/optimizer-tracing.html">tracing the optimizer</a>.</p>
<p>Bottom output is an &ldquo;EXPLAIN tree&rdquo; which is new as of MySQL 8.0. It shows the query execution plan <em>from the bottom up, per-node</em>. The EXPLAIN tree reads:</p>
<ol>
<li>Nested loop inner join
<ol>
<li>Table scan on t2</li>
<li>Index lookup on t1 using c1 (c1=t2.c2)</li>
</ol>
</li>
<li>Stream results</li>
<li>Sort: t1.c2</li>
</ol>
<p>Step 3 refers to &ldquo;Using temporary&rdquo; in the EXPLAIN plan, and step 4 refers to &ldquo;Using filesort&rdquo;. See <a href="https://petrunia.net/2007/08/29/how-mysql-executes-order-by/">How MySQL executes ORDER BY</a> by Sergei Petrunia for a beautifully illustrated explanation of MySQL ORDER BY.</p>
<p>The first table, <code>t2</code>, is a table scan (&ldquo;type: ALL&rdquo;), so <code>Select_scan</code> will be incremented. The second table, <code>t1</code>, is neither a table scan nor a range scan, so no metric will be incremented because there are no select metrics for other <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types">join types</a>. Let&rsquo;s clear the session metrics, execute the query, and check the select metrics:</p>
<pre tabindex="0"><code>mysql&gt; FLUSH STATUS;

mysql&gt; SELECT * FROM t1, t2 WHERE t1.c1 = t2.c2 ORDER BY t1.c2;
--
-- Output removed
--
20 rows in set (0.00 sec)

mysql&gt; SHOW SESSION STATUS LIKE &#39;Select_%&#39;;
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| Select_full_join       | 0     |
| Select_full_range_join | 0     |
| Select_range           | 0     |
| Select_range_check     | 0     |
| Select_scan            | 1     | -- t2
+------------------------+-------+
</code></pre><p>As expected, <code>Select_scan</code> = 1 due to the table scan on <code>t2</code>.</p>
<h3 id="select_scan">Select_scan</h3>
<p><code>Select_scan</code> refers to the first table in a join, or the only table if there is only one table. It means MySQL did a table <em>or</em> index scan. For such tables, EXPLAIN lists &ldquo;ALL&rdquo; or &ldquo;index&rdquo; in the &ldquo;type&rdquo; column.</p>
<p>Table scans (&ldquo;type: ALL&rdquo;) are usually (but not always) terrible for performance because reading an entire table is slow. However, table scans are common. It&rsquo;s not uncommon to see a server where 50% of all SELECT queries are <code>Select_scan</code>. A SELECT results in a table scan when no index can be used to for the WHERE conditions. From a performance perspective it&rsquo;s safe to say that you always want to decrease <code>Select_scan</code>—zero is best. However, in some cases the value of <code>Select_scan</code> can increase after optimizing queries because MySQL is able to do more. Ultimately, <code>Select_scan</code> is a performance limiter which should decrease to allow increased overall QPS (queries per second).</p>
<p>Index scans (&ldquo;type: index&rdquo;) are better than table scans, especially when &ldquo;Extra: Using index&rdquo; appears in the EXPLAIN plan which means a covering index is being used. Without &ldquo;Using index&rdquo;, the query is still a full table scan but MySQL uses the index to read rows in order, which is usually the result of an <a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html">ORDER BY optimization</a>.</p>
<h3 id="select_range">Select_range</h3>
<p><code>Select_range</code> refers to the first table in a join, or the only table if there is only one table. It means MySQL read a range of rows from the table. For such tables, EXPLAIN lists &ldquo;type: range&rdquo;. MySQL used an index to limit table reads to rows within the range, which saves time that would otherwise be wasted on disk seeks for non-matching rows. Therefore, <code>Select_range</code> is a lot faster than <code>Select_scan</code>. A query like <code>SELECT * FROM t1 WHERE c1 &gt; 5 AND c1 &lt; 13</code> specifies an exclusive range between 5 and 13.. Since column <code>c1</code> is indexed, MySQL reads the index for the range to find and read only rows in that range. If <code>c1</code> was not indexed, MySQL would have to do a full table scan. See <a href="https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html">Range Optimization</a> for a lot more details.</p>
<h3 id="select_full_join">Select_full_join</h3>
<p><code>Select_full_join</code> refers to the second or greater table in a join. It means MySQL did a table scan to join the table to the preceding table. For such tables, EXPLAIN lists &ldquo;ALL&rdquo; in the &ldquo;type&rdquo; column. <code>Select_full_join</code> results when no index can be used to join the table. Like <code>Select_scan</code>, this is a performance limiter that should be avoided.</p>
<p>The worst case is a table scan on both join tables:</p>
<pre tabindex="0"><code>mysql&gt; EXPLAIN SELECT * FROM t1, t2 WHERE t1.c2 = t2.c2 ;
+-------------+-------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
| select_type | table | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                      |
+-------------+-------+------+---------------+------+---------+------+------+----------+--------------------------------------------+
| SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |   20 |   100.00 | NULL                                       |
| SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |   26 |    10.00 | Using where; Using join buffer (hash join) |
+-------------+-------+------+---------------+------+---------+------+------+----------+--------------------------------------------+

mysql&gt; EXPLAIN FORMAT=TREE SELECT * FROM t1, t2 WHERE t1.c2 = t2.c2 ;
+-------------------------------------------------------------------------+
| EXPLAIN                                                                 |
+-------------------------------------------------------------------------+
| -&gt; Inner hash join (t2.c2 = t1.c2)  (cost=54.50 rows=52)
    -&gt; Table scan on t2  (cost=0.03 rows=26)
    -&gt; Hash
        -&gt; Table scan on t1  (cost=2.25 rows=20)                          |
+-------------------------------------------------------------------------+

mysql&gt; SHOW SESSION STATUS LIKE &#39;Select_%&#39;;
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| Select_full_join       | 1     | -- t2
| Select_full_range_join | 0     |
| Select_range           | 0     |
| Select_range_check     | 0     |
| Select_scan            | 1     | -- t1
+------------------------+-------+
</code></pre><p>The &ldquo;type: ALL&rdquo; for both tables indicates a table scan. <code>Select_full_join</code> was incremented for the table scan on the second table (<code>t2</code>), and <code>Select_scan</code> was incremented for the table scan on the first table (<code>t1</code>). This query does table scans because the tables are joined on column <code>c2</code> which is not indexed on either table.</p>
<p>This is the worst case because, as the MySQL manual notes:</p>
<blockquote>
<p>Because type is ALL for each table, this output indicates that MySQL is generating a Cartesian product of all the tables; that is, every combination of rows. This takes quite a long time, because the product of the number of rows in each table must be examined.</p>
</blockquote>
<p>The first table has 20 rows and the second has 26 rows, so the result is 20 * 26 = 520 rows. The worst I have ever seen was a three table join that caused a cross product of 112 billion rows (actually, the query never finished before it caused the server to halt). With only 1,000 rows in each table, the product is 1 million rows which will be noticeably slow.</p>
<p>Both EXPLAIN outputs show another new feature in MySQL 8.0: <a href="https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html">hash joins</a>. See <a href="https://mysqlserverteam.com/hash-join-in-mysql-8/">Hash join in MySQL 8</a> by the MySQL Server Team for an illustrated explanation.</p>
<h3 id="select_full_range_join">Select_full_range_join</h3>
<p><code>Select_full_range_join</code> refers to the second or greater table in a join. It means MySQL joined the table to the preceding table using a range scan, which is significantly better than <code>Select_full_join</code>. For such tables, EXPLAIN lists &ldquo;type: range&rdquo;. Like <code>Select_range</code>, <code>Select_full_range_join</code> requires an index and the same <a href="https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html">range optimizations</a> apply.</p>
<pre tabindex="0"><code>mysql&gt; EXPLAIN SELECT * FROM t1, t2 WHERE t1.c1 = 10 AND t2.c1 &gt; 13;
+-------------+-------+-------+---------------+------+---------+-------+------+----------+------------------------------------------------------+
| select_type | table | type  | possible_keys | key  | key_len | ref   | rows | filtered | Extra                                                |
+-------------+-------+-------+---------------+------+---------+-------+------+----------+------------------------------------------------------+
| SIMPLE      | t1    | ref   | c1            | c1   | 4       | const |    1 |   100.00 | NULL                                                 |
| SIMPLE      | t2    | range | c1            | c1   | 4       | NULL  |   13 |   100.00 | Using index condition; Using join buffer (hash join) |
+-------------+-------+-------+---------------+------+---------+-------+------+----------+------------------------------------------------------+

mysql&gt; EXPLAIN FORMAT=TREE SELECT * FROM t1, t2 WHERE t1.c1 = 10 AND t2.c1 &gt; 13;
+-----------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                                                                                                                                     |
+-----------------------------------------------------------------------------------------------+
| -&gt; Inner hash join (no condition)  (cost=6.46 rows=13)
    -&gt; Index range scan on t2 using c1, with index condition: (t2.c1 &gt; 13)  (cost=6.11 rows=13)
    -&gt; Hash
        -&gt; Index lookup on t1 using c1 (c1=10)  (cost=0.35 rows=1)                              |
+-----------------------------------------------------------------------------------------------+

mysql&gt; SHOW STATUS LIKE &#39;Select_%&#39;;
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| Select_full_join       | 0     |
| Select_full_range_join | 1     | -- t2
| Select_range           | 0     |
| Select_range_check     | 0     |
| Select_scan            | 0     |
+------------------------+-------+
</code></pre><p>Note that the condition on <code>t1</code> is constant: <code>t1.c1 = 10</code>. Since MySQL knows column values from the preceding table (<code>t1</code>), it also knows that it can use those column values to range scan the join table (<code>t2</code>). This is not always the case, as the next select metric indicates.</p>
<h3 id="select_range_check">Select_range_check</h3>
<p><code>Select_range_check</code> refers to the second or greater table in a join. It means &ldquo;MySQL checks whether it is possible to use a range or index_merge access method to retrieve rows.&rdquo; In other words, it means MySQL wants to do <code>Select_full_range_join</code> but cannot because it does not know the column values from the preceding table, so it checks the index on the join table for each new row (column values) from the preceding table.</p>
<pre tabindex="0"><code>mysql&gt; EXPLAIN SELECT * FROM t1, t2 WHERE t1.c1 &gt; t2.c1;
+-------------+-------+------+---------------+------+---------+------+------+----------+------------------------------------------------+
| select_type | table | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                          |
+-------------+-------+------+---------------+------+---------+------+------+----------+------------------------------------------------+
| SIMPLE      | t1    | ALL  | c1            | NULL | NULL    | NULL |   20 |   100.00 | NULL                                           |
| SIMPLE      | t2    | ALL  | c1            | NULL | NULL    | NULL |   26 |    33.33 | Range checked for each record (index map: 0x2) |
+-------------+-------+------+---------------+------+---------+------+------+----------+------------------------------------------------+

mysql&gt; EXPLAIN FORMAT=TREE SELECT * FROM t1, t2 WHERE t1.c1 &gt; t2.c1;
+--------------------------------------------------------------------------------------+
| EXPLAIN                                                                              |
+--------------------------------------------------------------------------------------+
| -&gt; Nested loop inner join  (cost=54.50 rows=173)
    -&gt; Table scan on t1  (cost=2.25 rows=20)
    -&gt; Filter: (t1.c1 &gt; t2.c1)  (cost=0.06 rows=9)
        -&gt; Index range scan on t2 (re-planned for each iteration)  (cost=0.06 rows=26) |
+--------------------------------------------------------------------------------------+

mysql&gt; SHOW SESSION STATUS LIKE &#39;Select_%&#39;;
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| Select_full_join       | 0     |
| Select_full_range_join | 0     |
| Select_range           | 0     |
| Select_range_check     | 1     | -- t2
| Select_scan            | 1     | -- t1
+------------------------+-------+
</code></pre><p>The condition <code>t1.c1 &gt; t2.c1</code> triggers the range check. As MySQL scans <code>t1</code>, it reads column <code>c1</code> values. In this example, we know the values ahead of time because the test table is tiny and static. But in a real database, table writes and transaction isolation levels mean the values can change, therefore MySQL cannot know them ahead of time. For each row, MySQL checks if can use the index on <code>t2.c1</code> to read the <code>t2</code> row matching the current <code>t1.c1</code> value. It is possible that <code>t1.c1</code> has values not in <code>t2.c1</code>.</p>
<p>Even if MySQL determines that it can do a range scan (or index merge), it does <em>not</em> increment <code>Select_full_range_join</code>. Only <code>Select_range_check</code> is incremented.</p>
<p>See &ldquo;Range checked for each record&rdquo; in <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">EXPLAIN Output Format</a> for a good explanation.</p>
<h2 id="sort">Sort</h2>
<p>The sort metrics <code>Sort_scan</code>, <code>Sort_range</code>, <code>Sort_merge_passes</code>, and <code>Sort_rows</code> apply to queries that use ORDER BY or GROUP BY, regardless of how many tables.</p>
<p>A sort as indicated by &ldquo;filesort&rdquo; in EXPLAIN output. The term &ldquo;filesort&rdquo; is misleading. The MySQL Server Team says, &ldquo;In MySQL, filesort is the catch-all algorithm for producing sorted results for ORDER-BY or GROUP-BY queries.&rdquo; (<a href="https://mysqlserverteam.com/filesort-optimization-in-5-7-3-pack-values-in-the-sort-buffer/">Filesort optimization in 5.7.3: pack values in the sort buffer</a>) See also <a href="https://www.percona.com/blog/2009/03/05/what-does-using-filesort-mean-in-mysql/">What does Using filesort mean in MySQL?</a></p>
<p>Memory allocation for sorting is set by the system variable <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sort_buffer_size">sort_buffer_size</a>. Resist the temptation to &ldquo;tune&rdquo; this variable or simply increase its value. Read <a href="https://www.xaprb.com/blog/2010/05/09/how-to-tune-mysqls-sort_buffer_size/">How to Tune MySQL’s Sort_buffer_size</a> by Baron and <a href="http://ronaldbradford.com/blog/more-on-understanding-sort_buffer_size-2010-05-10/">More on understanding sort_buffer_size
</a> by Ronald—both are long-time MySQL experts you can trust. Also read <a href="https://www.percona.com/blog/2010/10/25/impact-of-the-sort-buffer-size-in-mysql/">Impact of the sort buffer size in MySQL</a> by Percona.</p>
<p class="note">A of MySQL 8.0.12, <i>sort_buffer_size</i> is allocated incrementally as needed.<br>Before MySQL 8.0.12, the full size is allocated up front.</p>
<p>For a deeper technical understanding of sorting in MySQL 8.0, read <a href="http://www.unofficialmysqlguide.com/sorting.html">Sorting</a> in <em>The Unofficial MySQL 8.0 Optimizer Guide</em> by Morgan—another long-time MySQL expert you can trust.</p>
<h3 id="sort_scan">Sort_scan</h3>
<p>As of MySQL 8.0, <code>Sort_scan</code> is the total number of all sort operations. In MySQL 5.7 and older, <code>Sort_scan</code> was the number of sort operations for queries <em>not</em> using a range scan; see <a href="#sort_range">Sort_range</a>.</p>
<p>The value of <code>Sort_scan</code> is usually very high because sorting rows is common. Monitor the rate of this metric (sort ops/second) and watch for unexpected changes.</p>
<h3 id="sort_range">Sort_range</h3>
<p>As of MySQL 8.0, <code>Sort_range</code> means nothing. The status variable remains, but the code that incremented it was removed. In MySQL 5.7 the code was in <code>sql/filesort.cc</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (tab<span style="color:#f92672">-&gt;</span>quick())
</span></span><span style="display:flex;"><span>    thd<span style="color:#f92672">-&gt;</span>inc_status_sort_range();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    thd<span style="color:#f92672">-&gt;</span>inc_status_sort_scan();
</span></span></code></pre></div><p>But in MySQL 8.0 that if-else block was replaced with a single line:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  thd<span style="color:#f92672">-&gt;</span>inc_status_sort_scan();
</span></span></code></pre></div><p>In MySQL 5.7 and older, <code>Sort_range</code> and <code>Sort_scan</code> were mutually exclusive, as shown in the code snippet above. <code>Sort_range</code> was incremented instead of <code>Sort_scan</code> for queries using a range scan.</p>
<pre tabindex="0"><code>`Select_scan`  + filesort = `Sort_scan`++
`Select_range` + filesort = `Sort_range`++
</code></pre><p>Let&rsquo;s use MySQL 5.7.31 and the <code>salaries</code> table in the <a href="https://dev.mysql.com/doc/employee/en/">employees sample database</a>:</p>
<pre tabindex="0"><code>CREATE TABLE `salaries` (
  `emp_no` int(11) NOT NULL,
  `salary` int(11) NOT NULL,
  `from_date` date NOT NULL,
  `to_date` date NOT NULL,
  PRIMARY KEY (`emp_no`,`from_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
</code></pre><p>Column <code>salary</code> is not indexed, so the following query causes a table scan, not a range scan, which means <code>Sort_scan</code> will be incremented:</p>
<pre tabindex="0"><code>mysql&gt; EXPLAIN SELECT emp_no, salary FROM salaries WHERE salary &gt; 250000 ORDER BY emp_no, salary LIMIT 10;
+-------------+----------+------------+------+---------------+------+---------+------+---------+----------+-----------------------------+
| select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra                       |
+-------------+----------+------------+------+---------------+------+---------+------+---------+----------+-----------------------------+
| SIMPLE      | salaries | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2834690 |    33.33 | Using where; Using filesort |
+-------------+----------+------------+------+---------------+------+---------+------+---------+----------+-----------------------------+

mysql&gt; SELECT emp_no, salary FROM salaries WHERE salary &gt; 250000 ORDER BY emp_no, salary LIMIT 10;
Empty set (0.74 sec)

mysql&gt; SHOW SESSION STATUS LIKE &#39;Sort_%&#39;;
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Sort_merge_passes | 0     |
| Sort_range        | 0     |
| Sort_rows         | 0     |
| Sort_scan         | 1     | -- Due to type: ALL
+-------------------+-------+
</code></pre><p>Now the proof: index <code>salary</code> to cause a range scan:</p>
<pre tabindex="0"><code>mysql&gt; ALTER TABLE salaries ADD INDEX (salary);
Query OK, 0 rows affected (15.52 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; EXPLAIN SELECT emp_no, salary FROM salaries WHERE salary &gt; 250000 ORDER BY emp_no, salary LIMIT 10;
+-------------+----------+------------+-------+---------------+--------+---------+------+------+----------+------------------------------------------+
| select_type | table    | partitions | type  | possible_keys | key    | key_len | ref  | rows | filtered | Extra                                    |
+-------------+----------+------------+-------+---------------+--------+---------+------+------+----------+------------------------------------------+
| SIMPLE      | salaries | NULL       | range | salary        | salary | 4       | NULL |    1 |   100.00 | Using where; Using index; Using filesort |
+-------------+----------+------------+-------+---------------+--------+---------+------+------+----------+------------------------------------------+

mysql&gt; FLUSH STATUS;

mysql&gt; SELECT emp_no, salary FROM salaries WHERE salary &gt; 250000 ORDER BY emp_no, salary LIMIT 10;
Empty set (0.18 sec)

mysql&gt; SHOW SESSION STATUS LIKE &#39;Sort_%&#39;;
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Sort_merge_passes | 0     |
| Sort_range        | 1     | -- Due to type: range
| Sort_rows         | 0     |
| Sort_scan         | 0     |
+-------------------+-------+
</code></pre><p>Therefore, in MySQL 5.7 and older, the total number of all sort operations is <code>Sort_scan + Sort_range</code>.</p>
<h3 id="sort_merge_passes">Sort_merge_passes</h3>
<p><code>Sort_merge_passes</code> is the number of merge buffer operations. <code>Sort_merge_passes</code> is incremented by 1 each time function <code>merge_buffers()</code> is called (in <code>sql/filesort.cc</code>).</p>
<p>When <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sort_buffer_size">sort_buffer_size</a> is not large enough to hold all unsorted rows, MySQL writes &ldquo;merge buffers&rdquo; to temporary files on disk, then merges the buffers to produce the final, sorted result.</p>
<p>Let&rsquo;s use a table with 1 million rows created by <a href="https://github.com/akopytov/sysbench">sysbench</a>:</p>
<pre tabindex="0"><code>CREATE TABLE `sbtest1` (
  `id` int NOT NULL AUTO_INCREMENT,
  `k` int NOT NULL DEFAULT &#39;0&#39;,
  `c` char(120) NOT NULL DEFAULT &#39;&#39;,
  `pad` char(60) NOT NULL DEFAULT &#39;&#39;,
  PRIMARY KEY (`id`),
  KEY `k_1` (`k`)
) ENGINE=InnoDB AUTO_INCREMENT=1000001 DEFAULT CHARSET=utf8 |
</code></pre><p>The query,</p>
<pre tabindex="0"><code class="language-none" data-lang="none">SELECT c FROM sbtest1 WHERE id &gt; 100 ORDER BY c
</code></pre><p>produces a sorted result of 999,900 rows which does not fit in any sane <code>sort_buffer_size</code>, thereby causing merge buffers to disk and sort merge passes.</p>
<p>As mentioned at the beginning of the <a href="#sort">Sort</a> section: <em>Resist the temptation to “tune” this variable or simply increase its value.</em> But to demonstrate how <code>sort_buffer_size</code> affects <code>Sort_merge_passes</code> and query response time, let&rsquo;s try the query above with different sort buffer sizes: 32 KB (minimum), 10 MB (very large), 32 MB (dangerous), and 128 MB (insane).</p>
<p><em><strong>sort_buffer_size = 32 KB (minimum)</strong></em></p>
<pre tabindex="0"><code>mysql&gt; SELECT c FROM sbtest1 WHERE id &gt; 100 ORDER BY c;
--
-- Output removed
--
999900 rows in set (3.60 sec)

mysql&gt; SHOW SESSION STATUS LIKE &#39;Sort_%&#39;;
+-------------------+--------+
| Variable_name     | Value  |
+-------------------+--------+
| Sort_merge_passes | 1917   |
| Sort_range        | 0      |
| Sort_rows         | 999900 |
| Sort_scan         | 1      |
+-------------------+--------+
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span><span style="color:#e6db74">&#34;filesort_summary&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;memory_available&#34;</span>: <span style="color:#ae81ff">32768</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;key_size&#34;</span>: <span style="color:#ae81ff">240</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;row_size&#34;</span>: <span style="color:#ae81ff">610</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;max_rows_per_buffer&#34;</span>: <span style="color:#ae81ff">53</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_rows_estimate&#34;</span>: <span style="color:#ae81ff">493200</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_rows_found&#34;</span>: <span style="color:#ae81ff">999900</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_initial_chunks_spilled_to_disk&#34;</span>: <span style="color:#ae81ff">11494</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;peak_memory_used&#34;</span>: <span style="color:#ae81ff">33368</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;sort_algorithm&#34;</span>: <span style="color:#e6db74">&#34;std::sort&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;sort_mode&#34;</span>: <span style="color:#e6db74">&#34;&lt;fixed_sort_key, packed_additional_fields&gt;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With only 32 KB, MySQL must use 11,494 merge buffers as indicated by <code>num_initial_chunks_spilled_to_disk</code> in the <a href="https://dev.mysql.com/doc/internals/en/optimizer-tracing.html">optimizer trace</a> output at bottom. (This value was fixed as of <a href="https://dev.mysql.com/doc/relnotes/mysql/8.0/en/news-8-0-2.html">MySQL 8.0.2</a>: &ldquo;In optimizer trace output, num_tmp_files did not actually indicate number of files. It has been renamed to num_initial_chunks_spilled_to_disk and indicates the number of chunks before any merging has occurred. (Bug #25733784, Bug #85487)&rdquo;.) The number of merge passes (1,917) is far less because each call to <code>merge_buffers()</code> merges several buffers (currently 7: <code>constexpr size_t MERGEBUFF = 7;</code> in <code>sql/sql_sort.h</code>). All 32 KB was used, as indicated by <code>peak_memory_used</code>.</p>
<p>The query took 3.6s to execute.</p>
<p><em><strong>sort_buffer_size = 10 MB (very large)</strong></em></p>
<p>Does a very large sort buffer increase query response time? Let&rsquo;s try 10 MB:</p>
<pre tabindex="0"><code>mysql&gt; SELECT c FROM sbtest1 WHERE id &gt; 100 ORDER BY c;
--
-- Output removed
--
999900 rows in set (2.49 sec)

mysql&gt; SHOW SESSION STATUS LIKE &#39;Sort_%&#39;;
+-------------------+--------+
| Variable_name     | Value  |
+-------------------+--------+
| Sort_merge_passes | 6      |
| Sort_range        | 0      |
| Sort_rows         | 999900 |
| Sort_scan         | 1      |
+-------------------+--------+
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span><span style="color:#e6db74">&#34;filesort_summary&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;memory_available&#34;</span>: <span style="color:#ae81ff">10485760</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;key_size&#34;</span>: <span style="color:#ae81ff">240</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;row_size&#34;</span>: <span style="color:#ae81ff">610</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;max_rows_per_buffer&#34;</span>: <span style="color:#ae81ff">17189</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_rows_estimate&#34;</span>: <span style="color:#ae81ff">493200</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_rows_found&#34;</span>: <span style="color:#ae81ff">999900</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_initial_chunks_spilled_to_disk&#34;</span>: <span style="color:#ae81ff">36</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;peak_memory_used&#34;</span>: <span style="color:#ae81ff">10486104</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;sort_algorithm&#34;</span>: <span style="color:#e6db74">&#34;std::stable_sort&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;sort_mode&#34;</span>: <span style="color:#e6db74">&#34;&lt;fixed_sort_key, packed_additional_fields&gt;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Yes, query response time decreased 30% to 2.49s due to a 99.7% decrease in <code>Sort_merge_passes</code>: 1917 to 6. MySQL used all 10 MB of the sort buffer.</p>
<p><em><strong>sort_buffer_size = 32 MB (dangerous)</strong></em></p>
<pre tabindex="0"><code>mysql&gt; SELECT c FROM sbtest1 WHERE id &gt; 100 ORDER BY c;
--
-- Output removed
--
999900 rows in set (2.24 sec)

mysql&gt; SHOW SESSION STATUS LIKE &#39;Sort_%&#39;;
+-------------------+--------+
| Variable_name     | Value  |
+-------------------+--------+
| Sort_merge_passes | 1      |
| Sort_range        | 0      |
| Sort_rows         | 999900 |
| Sort_scan         | 1      |
+-------------------+--------+
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span><span style="color:#e6db74">&#34;filesort_summary&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;memory_available&#34;</span>: <span style="color:#ae81ff">33554432</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;key_size&#34;</span>: <span style="color:#ae81ff">240</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;row_size&#34;</span>: <span style="color:#ae81ff">610</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;max_rows_per_buffer&#34;</span>: <span style="color:#ae81ff">55007</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_rows_estimate&#34;</span>: <span style="color:#ae81ff">493200</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_rows_found&#34;</span>: <span style="color:#ae81ff">999900</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_initial_chunks_spilled_to_disk&#34;</span>: <span style="color:#ae81ff">12</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;peak_memory_used&#34;</span>: <span style="color:#ae81ff">33557336</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;sort_algorithm&#34;</span>: <span style="color:#e6db74">&#34;std::stable_sort&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;sort_mode&#34;</span>: <span style="color:#e6db74">&#34;&lt;fixed_sort_key, packed_additional_fields&gt;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With a 32 MB sort buffer, merge passes drops to 1 but query response time remains similar to a 10 MB sort buffer: 2.24s vs. 2.49s, respectively. Not surprising: 1 merge pass vs. 6 is not a significant difference.</p>
<p>I call a 32 MB <code>sort_buffer_size</code> &ldquo;dangerous&rdquo; for two reasons. First, sort buffers are allocated per-connection, so it can use a lot of memory on busy servers. Second, several MySQL experts recommend against large values. Granted, each server is different, so do your own analysis and use a larger <code>sort_buffer_size</code> if there is a proven need for it. As of MySQL 8.0.12, <code>sort_buffer_size</code> is allocated incrementally as needed, so it is less dangerous.</p>
<p><em><strong>sort_buffer_size = 128 MB (insane)</strong></em></p>
<pre tabindex="0"><code>mysql&gt; SELECT c FROM sbtest1 WHERE id &gt; 100 ORDER BY c;
--
-- Output removed
--
999900 rows in set (2.52 sec)

mysql&gt; SHOW SESSION STATUS LIKE &#39;Sort_%&#39;;
+-------------------+--------+
| Variable_name     | Value  |
+-------------------+--------+
| Sort_merge_passes | 1      |
| Sort_range        | 0      |
| Sort_rows         | 999900 |
| Sort_scan         | 1      |
+-------------------+--------+
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span><span style="color:#e6db74">&#34;filesort_summary&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;memory_available&#34;</span>: <span style="color:#ae81ff">134217728</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;key_size&#34;</span>: <span style="color:#ae81ff">240</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;row_size&#34;</span>: <span style="color:#ae81ff">610</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;max_rows_per_buffer&#34;</span>: <span style="color:#ae81ff">220029</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_rows_estimate&#34;</span>: <span style="color:#ae81ff">493200</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_rows_found&#34;</span>: <span style="color:#ae81ff">999900</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;num_initial_chunks_spilled_to_disk&#34;</span>: <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;peak_memory_used&#34;</span>: <span style="color:#ae81ff">134229360</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;sort_algorithm&#34;</span>: <span style="color:#e6db74">&#34;std::stable_sort&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;sort_mode&#34;</span>: <span style="color:#e6db74">&#34;&lt;fixed_sort_key, packed_additional_fields&gt;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A 128 MB <code>sort_buffer_size</code> proves an important point: <mark>performance can <em>decrease</em>  when <code>sort_buffer_size</code> is too large</mark>.</p>
<p>Query response time was 2.52s with 128 MB compared to 2.24s with 32 MB and 2.49s with 10 MB. Why? I do not have formal proof, but I am confident that it is due to the fact that <code>Sort_merge_passes</code> is negligible (1, 1, 6, respectively) but it takes longer to allocate 128 MB since, as of MySQL 8.0.12, sort buffer memory is allocated incrementally as needed which means more overhead to allocate large amounts of memory.</p>
<h3 id="sort_rows">Sort_rows</h3>
<p><code>Sort_rows</code> is the total number of rows sorted. The value is usually so high that it is nearly meaningless, even as a rate (rows sorted/second). If necessary, monitor the rate and watch for unexpected changes.</p>
</article>
	</div>
	<nav id="toc">
		<em><a href="#">MySQL Select and Sort Status Variables</a></em>
		<hr>
		<nav id="TableOfContents">
  <ul>
    <li><a href="#select">Select</a>
      <ul>
        <li><a href="#select_scan">Select_scan</a></li>
        <li><a href="#select_range">Select_range</a></li>
        <li><a href="#select_full_join">Select_full_join</a></li>
        <li><a href="#select_full_range_join">Select_full_range_join</a></li>
        <li><a href="#select_range_check">Select_range_check</a></li>
      </ul>
    </li>
    <li><a href="#sort">Sort</a>
      <ul>
        <li><a href="#sort_scan">Sort_scan</a></li>
        <li><a href="#sort_range">Sort_range</a></li>
        <li><a href="#sort_merge_passes">Sort_merge_passes</a></li>
        <li><a href="#sort_rows">Sort_rows</a></li>
      </ul>
    </li>
  </ul>
</nav>
	</nav>
</main>

    <footer>
  <p class="copyright text-muted">
    Copyright 2023 Daniel Nichter
  </p>
  <p><a href="https://github.com/daniel-nichter" alt="GitHub"><img src="https://hackmysql.com/img/mark-github.svg" alt="GitHub Invertocat logo"></a></p>
</footer>
<script src="https://hackmysql.com/js/compressed.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="https://cdn.usefathom.com/script.js" data-site="WJIYGVMB" data-canonical="false" defer></script>


  </body>
</html>
